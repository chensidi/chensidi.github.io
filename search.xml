<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git提交规范定制流程</title>
    <url>/2022/10/01/commit-lint-steps/</url>
    <content><![CDATA[<h2 id="需要一个git辅助提交工具"><a href="#需要一个git辅助提交工具" class="headerlink" title="需要一个git辅助提交工具"></a>需要一个git辅助提交工具</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很多人在使用git提交代码的时候，通常会使用命令行，例如 <code>git commit -m &#39;评论组件功能编码&#39;</code>，这样没有问题，甚至你直接使用ide自带的工具也能提交，但是其他人并不知道你这个描述，代表的是哪种提交类型，因为我们希望其他人在看到这条记录的时候，能够一眼就能看出这是哪类的 commit，所以社区内逐渐形成了多种 commit 格式规范，典型的就是<code>约定式提交</code>，或者 <code>conventionalcommits</code>，这是基于angular约定的一种规范，详情可参考<a href="https://www.conventionalcommits.org/en/v1.0.0/">约定式提交规范</a></p>
<h3 id="提交范例"><a href="#提交范例" class="headerlink" title="提交范例"></a>提交范例</h3><p>在约定式提交规范里，有以下几种格式</p>
<ul>
<li><p>新功能开发</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;feat: 回复功能的开发&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bug修复</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;fix(components): 评论组件嵌套问题修改&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码风格调整</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;style: 代码统一缩进，函数全部改为箭头函数表达式&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码调整</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;test: 测试案例调整&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文档相关更改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;docs: 功能文档api部分编写&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面几种是比较常用的提交格式，通俗来说就是由三部分组成<br><code>git commit &lt;type&gt;(scope): your description</code></p>
<ol>
<li>类型（type），除上述案例中的类型外，build:、chore:、 ci、style:、refactor:、perf，也可以根据需要自定义</li>
<li>影响范围，也叫scope，这个值是可选的，目的是告诉大家这次提交会波及哪些代码功能范围</li>
<li>描述，本次提交的简洁描述，也就是平时大家最常写的内容</li>
</ol>
<p>除了上面这三个组成部分，其实还有一些部分，例如脚注，相关的issue，有无破坏性改变，它的完整结构应该是这样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;[optional scope]: &lt;description&gt;</span><br><span class="line"></span><br><span class="line">[optional body]</span><br><span class="line"></span><br><span class="line">[optional footer(s)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h3><p>由于提交一次代码，要做到上述的结构规范对于初学者来说，稍微困难，特别是类型很多时不一定能敲出正确的type，所以我们希望能有一款智能提示插件，能引导我们去完成提交结构的组装，社区里有一款插件正好能满足这个需求，那就是 <a href="https://www.npmjs.com/package/cz-customizable">cz-customizable</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add cz-customizable -D</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在 package.json 里面，添加如下配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;commitizen&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node_modules/cz-customizable&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后在根目录添加 <code>.cz-config.js</code>，这个js就是为该插件做配置，你也可以重命名，具体参考官方文档，js示例内容如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// commit类型选择</span></span><br><span class="line">  <span class="attr">types</span>: [</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;feat&#x27;</span>,   <span class="attr">name</span>: <span class="string">&#x27;feat:  新功能开发&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;bug&#x27;</span>,    <span class="attr">name</span>: <span class="string">&#x27;fix:   bug修复&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;test&#x27;</span>,   <span class="attr">name</span>: <span class="string">&#x27;test:  测试功能&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;style&#x27;</span>,  <span class="attr">name</span>: <span class="string">&#x27;style: 代码样式调整&#x27;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">allowCustomScopes</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">allowBreakingChanges</span>: [<span class="string">&#x27;feat&#x27;</span>, <span class="string">&#x27;fix&#x27;</span>],</span><br><span class="line">  <span class="attr">skipQuestions</span>: [<span class="string">&#x27;scope&#x27;</span>, <span class="string">&#x27;footer&#x27;</span>],</span><br><span class="line">  <span class="comment">// 命令行交互信息</span></span><br><span class="line">  <span class="attr">messages</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;选择你的提交类型\n&#x27;</span>,</span><br><span class="line">    <span class="attr">scope</span>: <span class="string">&#x27;选择你的改变范围:\n&#x27;</span>,</span><br><span class="line">    <span class="comment">// used if allowCustomScopes is true</span></span><br><span class="line">    <span class="attr">customScope</span>: <span class="string">&#x27;填写改变范围:&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;填写简洁的描述信息:\n&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&#x27;填写详细的描述，可以使用 | 进行换行:\n&#x27;</span>,</span><br><span class="line">    <span class="attr">breaking</span>: <span class="string">&#x27;列举有破坏性的改变:\n&#x27;</span>,</span><br><span class="line">    <span class="attr">footer</span>: <span class="string">&#x27;列举关闭的issue. E.g.: #31, #34:\n&#x27;</span>,</span><br><span class="line">    <span class="attr">confirmCommit</span>: <span class="string">&#x27;你确定要提交本次更改?&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做了之后，我们尝试改变一些业务代码，然后我们尝试提交，这里就可以使用 <code>git cz</code>命令行了</p>
<blockquote>
<p>注意，git cz不是git自带的命令，而是安装并配置了插件之后，对git命令增强的</p>
</blockquote>
<p>然后我们发现，出现了交互式命令行<br><img src="/../imgs/1.jpg" alt="img"><br>然后我们按照指示步骤往下走，最终就会得到完整的提交信息结构<br><img src="/../imgs/2.jpg" alt="img"><br>这样，借助这款工具就能轻易地完成一次精准的格式提交</p>
<p>当然，上面的案例只是演示，具体需要哪种风格的格式，可以自行配置，官网还有很多可以自定义的选项。</p>
<h2 id="校验提交格式"><a href="#校验提交格式" class="headerlink" title="校验提交格式"></a>校验提交格式</h2><p>上面的内容介绍了如何让我们能够通过工具完成一次精确的提交，但是并不阻碍我们可以直接使用 <code>git commit</code>提交，记住<code>git cz</code> 只是辅助你完成格式构建，但并不是强制的，所以当你使用 <code>git commit</code> 命令的时候，随意提交内容，目前来看还是能够顺利通过的，所以需要对提交来的格式做校验，拦截不符合要求的 commit log</p>
<h3 id="commitlint介绍"><a href="#commitlint介绍" class="headerlink" title="commitlint介绍"></a>commitlint介绍</h3><p>commitlint是用作校验提交格式的，官网是<a href="https://commitlint.js.org/#/">commitlint</a><br>我们每一次在提交之后，都应该经过commitlint的校验后才能通过，接下来介绍使用方法</p>
<h4 id="安装commitLint"><a href="#安装commitLint" class="headerlink" title="安装commitLint"></a>安装commitLint</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意这里是两个依赖</span></span><br><span class="line">yarn add @commitlint/cli @commitlint/config-conventional</span><br></pre></td></tr></table></figure>

<h4 id="配置config文件"><a href="#配置config文件" class="headerlink" title="配置config文件"></a>配置config文件</h4><p>要想使用commitlint，需要在根目录下新建 <code>commitlint.config.js</code>，示例内容如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;@commitlint/config-conventional&#x27;</span>], <span class="comment">// 配置继承自约定式config</span></span><br><span class="line">  <span class="attr">rules</span>: &#123; <span class="comment">// 规则</span></span><br><span class="line">    <span class="string">&#x27;type-enum&#x27;</span>: [ <span class="comment">// 对应提交类型</span></span><br><span class="line">      <span class="number">2</span>, <span class="comment">// 可选0,1,2分别代表禁用，警告，报错</span></span><br><span class="line">      <span class="string">&#x27;always&#x27;</span>, <span class="comment">// never|always, 禁用，启用</span></span><br><span class="line">      [</span><br><span class="line">        <span class="string">&#x27;feat&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;fix&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;style&#x27;</span>,</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更多自定义配置参考官网</span></span><br></pre></td></tr></table></figure>

<h3 id="配置husky"><a href="#配置husky" class="headerlink" title="配置husky"></a>配置husky</h3><p>现在我们还暂时不能完成 commitlint，因为对提交的校验，是发生在git commit的hook前，只有这个钩子通过了，才能真正通过commit，所以husky就是做这些事情的，通俗说，husky就是为触发git各种hook，执行对应的脚本程序</p>
<h4 id="安装husky依赖"><a href="#安装husky依赖" class="headerlink" title="安装husky依赖"></a>安装husky依赖</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add husky -D</span><br></pre></td></tr></table></figure>

<h4 id="初始化husky"><a href="#初始化husky" class="headerlink" title="初始化husky"></a>初始化husky</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx husky install</span><br></pre></td></tr></table></figure>

<p>或者你希望在 yarn install安装依赖之后自动触发，可以在 package.json 文件中的 scripts 字段下添加</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prepare&quot;</span><span class="punctuation">:</span> <span class="string">&quot;husky install&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在husky install执行之后，会在根目录下生成 <code>.husky</code> 文件，然后我们可以添加一个对commit-msg的钩子处理脚本命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx husky add .husky/commit-msg  &quot;npx --no -- commitlint --edit $&#123;1&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>这条命令会在 <code>.husky</code> 目录下生成 <code>commit-msg</code>文件</p>
<p>这就会在git commit时，触发其对应钩子，使用commitlint插件对本次commit信息进行校验</p>
<h3 id="尝试使用"><a href="#尝试使用" class="headerlink" title="尝试使用"></a>尝试使用</h3><p>现在我们就能够对提交信息进行校验了，尝试提交一个功能。<br><img src="/../imgs/3.jpg" alt="img"></p>
<p>我们发现，本次提交并没有通过，因为我们的 <code>commitling.config.js</code> 中配置了，并且提交类型是必须的，所以我们需要改写为正确的格式 <code>git commit -m &#39;feat(components): 开发评论组件&#39;</code>，然后校验通过</p>
<p>我们也可以结合之前的 <code>git cz</code> 命令，完成一次严格的commit操作</p>
<blockquote>
<p>再次说明，示例配置的只是为了演示，具体的情况视各位的项目为准，可以对 <code>.cz-config.js</code> 和 <code>commitlint.config.js</code> 内容自行定制</p>
</blockquote>
<h2 id="添加eslint"><a href="#添加eslint" class="headerlink" title="添加eslint"></a>添加eslint</h2><p>eslint是js&#x2F;ts 的校验工具，具体使用方法请参考官网，这里只介绍如何配置在git commit流程中，让每次commit之前都完成 eslint 的校验，保证代码规范。下面介绍步骤</p>
<h3 id="eslint配置"><a href="#eslint配置" class="headerlink" title="eslint配置"></a>eslint配置</h3><h4 id="安装eslint"><a href="#安装eslint" class="headerlink" title="安装eslint"></a>安装eslint</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add eslint -D</span><br></pre></td></tr></table></figure>

<h4 id="添加scripts命令"><a href="#添加scripts命令" class="headerlink" title="添加scripts命令"></a>添加scripts命令</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;eslint:init&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx eslint --init&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eslint:lint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint --ext .js,.ts,.tsx,.jsx,.vue src/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eslint:fix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint --fix --ext .js,.ts,.tsx,.jsx,.vue src/&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后分别执行 <code>yarn eslint:init</code>，这是 eslint 的初始化命令，eslint 会引导你渐进式地使用个性化的一套流程，然后会生成<br><code>.eslintrc.js</code> 文件，也就是校验规则</p>
<p>执行 <code>yarn eslint:lint</code> 则会完成校验工作，执行 <code>yarn eslint:fix</code> 这个则是根据你的配置完成修复</p>
<h3 id="添加pre-commit钩子"><a href="#添加pre-commit钩子" class="headerlink" title="添加pre-commit钩子"></a>添加pre-commit钩子</h3><p>如果没有 pro-commit 钩子，那么无法在commit 的时候自动校验，只能手动执行lint命令校验，所以需要一个钩子去触发校验</p>
<p>执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx husky add ./husky pre-commit &quot;yarn eslint:lint&quot;</span><br></pre></td></tr></table></figure>

<p>就会生成  <code>pre-commit</code> 文件，也就是提交前的钩子，执行的脚本命令就是 <code>yarn eslint:lint</code>.</p>
<p>这样我们在每次提交的时候，就会先执行 eslint 校验，之后再进入格式校验</p>
<h3 id="添加lintstaged"><a href="#添加lintstaged" class="headerlink" title="添加lintstaged"></a>添加lintstaged</h3><p>想一下，如果我们每次提交都要对整个工程进行eslint校验，一旦项目过大，就会非常耗时，并且不合理，因为按理讲<br>只需要校验本人提交的部分就行了，没必要去校验其他的文件，所以需要一个插件来让eslint去识别暂存区的内容。</p>
<h4 id="安装lintstaged依赖"><a href="#安装lintstaged依赖" class="headerlink" title="安装lintstaged依赖"></a>安装lintstaged依赖</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add lintstaged</span><br></pre></td></tr></table></figure>

<h4 id="设置lintstaged相关配置"><a href="#设置lintstaged相关配置" class="headerlink" title="设置lintstaged相关配置"></a>设置lintstaged相关配置</h4><p>设置的方式有几种，这里介绍其中一种，其他的则触类旁通</p>
<ul>
<li><p>新建 <code>.lintstagedrc</code> 文件在根目录，内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;src/**/*&#123;.js,.ts,.jsx,.tsx,.vue&#125;&quot;: &quot;yarn eslint:lint&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是支持 glob 模式，对应上你自己的eslint 命令，这段配置的意思就是，检测 src 下，所有对应.js,.ts,.jsx,.tsx,.vue后缀内的文件，去用eslint: lint 命令去校验</p>
</li>
</ul>
<h4 id="更改husky的pre-commit钩子"><a href="#更改husky的pre-commit钩子" class="headerlink" title="更改husky的pre-commit钩子"></a>更改husky的pre-commit钩子</h4><p>之前我们设置的pre-commit 内容是 <code>yarn eslint:lint</code>，这是去校验整个项目的文件，现在需要改成只校验暂存区内容</p>
<p><code>npx lint-staged</code>，完整命令是 <code>npx husky add ./husky pre-commit &quot;npx lint-staged&quot;</code></p>
<p>这样配置后，整个提交流程就是，先触发pre-commit 钩子的脚本，lint-staged 插件找出暂存区的文件，然后按照 <code>.lintstagedrc</code> 中的配置，对目标后缀文件进行eslint校验命令，通过后进行git 提交格式规范命令。</p>
]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript红宝书重点记录《基础类型篇》</title>
    <url>/2022/11/08/base-type/</url>
    <content><![CDATA[<h2 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h2><p>Symbol是es6中新增的一种基本数据类型，也可以读成“符号”，其特点如下</p>
<ol>
<li><p>不重复性，js中字符串，数字，和对象可以做到完全相等，但Symbol是不存在一模一样的两个值的，即便是 <code>Symbol() == Symbol()</code> 也是false，基于这个特点，当对象的属性为Symbol类型时，是不用担心某些属性会被覆盖的</p>
</li>
<li><p>不能使用 new 操作符，Symbol只能用做普通函数调用，当然可以用它的 call，apply，bind</p>
</li>
<li><p>可以全局注册Symbol，当采用普通函数调用时，Symbol得到的只是局部的符号值，下一次再调用时会重新注册，但Symbol提供了全局注册方法，<code>Symbol.for</code>，如果全局没有注册，则分配一个内存空间赋予首次的Symbol，下次再此注册时会直接使用内存中的值，所以在这种情况下，就能够得到两个完全相同的Symbol，这与第一点是有区别的，例如</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="number">1</span>) <span class="comment">// 首次注册</span></span><br><span class="line"><span class="keyword">const</span> ss = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="number">1</span>) <span class="comment">// 从注册表中获取</span></span><br><span class="line">ss === s <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> Symbol还提供了与for对应的一个方法，keyFor，这是用来获取传入for参数的方法，因为使用for方法，传入的参数最终都会转换为string类型，所以通过keyFor得到的数据，也都是string，当然如果调用for时没有传，那keyFor得到的也就是undefined</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sy = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(sy) <span class="comment">// &#x27;true&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>keyFor只能接受Symbol类型，其余类型一概报错</p>
</blockquote>
</li>
<li><p>Symbol函数是接受参数的，该参数是作为该Symbol值的描述，为以后寻找该Symbol提供了追踪依据，参数一般传入的是字符串类型，但实际上能接受任何类型，只不过传入的类型最终都会变成字符串类型，例如数字，布尔会转成字符串，对象类型，会调用其<code>toString</code>方法，返回的结果作为Symbol入参的最终结果</p>
</li>
<li><p>Symbol.toPrimitive，当一个对象存在该属性时，如果该对象作隐式类型转换，会优先调用该方法，它的存在使得优先级高于<code>valueOf</code> 和 <code>toString</code>，需要注意，这个属性值必须是函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](type) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(type)</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;messi&#x27;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">35</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;🏆&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">1</span> <span class="comment">// 打印default，+ 运算可以是数字，也可以是字符串不明确，所以为default类型</span></span><br><span class="line">obj * <span class="number">1</span> <span class="comment">// 打印number，因为作数学运算需要转化为number</span></span><br><span class="line"><span class="title class_">Symbol</span>(obj) <span class="comment">// 打印string，Symbol的入参需要转换为string类型</span></span><br></pre></td></tr></table></figure>

<p>也即是说，Symbol.toPrimitive对应的方法，接受的参数类型，是取决于作隐式转换时需要被转换成的数据类型，如果该对象没有这个属性，才去找有没有 <code>valueOf</code> 和 <code>toString</code> 方法</p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>eslint常用推荐配置项</title>
    <url>/2022/10/30/eslint/</url>
    <content><![CDATA[<p>以下是eslint的rules规范</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;prefer-const&#x27;</span>: [</span><br><span class="line">    <span class="comment">// 优先使用const</span></span><br><span class="line">    <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">destructuring</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">      <span class="attr">ignoreReadBeforeAssign</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&#x27;no-const-assign&#x27;</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// const变量不允许修改</span></span><br><span class="line">  <span class="string">&#x27;no-var&#x27;</span>: <span class="number">2</span>, <span class="comment">// 不准使用var</span></span><br><span class="line">  <span class="string">&#x27;comma-dangle&#x27;</span>: [</span><br><span class="line">    <span class="comment">// 拖尾逗号情况</span></span><br><span class="line">    <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">arrays</span>: <span class="string">&#x27;never&#x27;</span>,</span><br><span class="line">      <span class="attr">objects</span>: <span class="string">&#x27;always-multiline&#x27;</span>,</span><br><span class="line">      <span class="attr">imports</span>: <span class="string">&#x27;always-multiline&#x27;</span>,</span><br><span class="line">      <span class="attr">exports</span>: <span class="string">&#x27;always-multiline&#x27;</span>,</span><br><span class="line">      <span class="attr">functions</span>: <span class="string">&#x27;never&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&#x27;@typescript-eslint/comma-dangle&#x27;</span>: [</span><br><span class="line">    <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">arrays</span>: <span class="string">&#x27;never&#x27;</span>,</span><br><span class="line">      <span class="attr">objects</span>: <span class="string">&#x27;always-multiline&#x27;</span>,</span><br><span class="line">      <span class="attr">imports</span>: <span class="string">&#x27;always-multiline&#x27;</span>,</span><br><span class="line">      <span class="attr">exports</span>: <span class="string">&#x27;always-multiline&#x27;</span>,</span><br><span class="line">      <span class="attr">functions</span>: <span class="string">&#x27;never&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&#x27;no-new-object&#x27;</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// 不允许new Object，应采用字面量</span></span><br><span class="line">  <span class="string">&#x27;quote-props&#x27;</span>: [</span><br><span class="line">    <span class="comment">// 对象属性添加引号</span></span><br><span class="line">    <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;as-needed&#x27;</span>, <span class="comment">// 有必要时添加</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">keywords</span>: <span class="literal">true</span>, <span class="comment">// 关键字必须加引号</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">quotes</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;single&#x27;</span>], <span class="comment">// 字符串用单引号</span></span><br><span class="line">  <span class="string">&#x27;no-unused-vars&#x27;</span>: <span class="number">1</span>, <span class="comment">// 未使用的变量警告</span></span><br><span class="line">  <span class="string">&#x27;prefer-destructuring&#x27;</span>: [</span><br><span class="line">    <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 优先使用解构</span></span><br><span class="line">      <span class="attr">array</span>: <span class="literal">false</span>, <span class="comment">// 数组不强制</span></span><br><span class="line">      <span class="attr">object</span>: <span class="literal">true</span>, <span class="comment">// 对象强制</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&#x27;prefer-template&#x27;</span>: <span class="number">2</span>, <span class="comment">// 优先使用模板字符串</span></span><br><span class="line">  <span class="string">&#x27;template-curly-spacing&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;always&#x27;</span>], <span class="comment">// 模板字符串周围需要空格</span></span><br><span class="line">  <span class="string">&#x27;space-before-function-paren&#x27;</span>: [</span><br><span class="line">    <span class="comment">// 函数() 前需要空格？</span></span><br><span class="line">    <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">anonymous</span>: <span class="string">&#x27;never&#x27;</span>, <span class="comment">// 函数声明不需要</span></span><br><span class="line">      <span class="attr">named</span>: <span class="string">&#x27;never&#x27;</span>, <span class="comment">// 函数表达式不需要</span></span><br><span class="line">      <span class="attr">asyncArrow</span>: <span class="string">&#x27;always&#x27;</span>, <span class="comment">// async箭头函数需要</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&#x27;arrow-spacing&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, &#123; <span class="attr">before</span>: <span class="literal">true</span>, <span class="attr">after</span>: <span class="literal">true</span> &#125;], <span class="comment">// 箭头函数 =&gt; 前后需要空格</span></span><br><span class="line">  <span class="string">&#x27;func-style&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;expression&#x27;</span>], <span class="comment">// 使用函数表达式，而非函数声明</span></span><br><span class="line">  <span class="string">&#x27;no-loop-func&#x27;</span>: <span class="number">2</span>, <span class="comment">// 禁止在循环中包含不安全引用的任何函数</span></span><br><span class="line">  <span class="string">&#x27;no-param-reassign&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, &#123; <span class="string">&quot;props&quot;</span>: <span class="literal">true</span> &#125;], <span class="comment">// 禁止对函数参数及属性重新赋值</span></span><br><span class="line">  <span class="string">&#x27;prefer-arrow-callback&#x27;</span>: <span class="number">2</span>, <span class="comment">// 作为参数的回调函数使用箭头函数</span></span><br><span class="line">  <span class="string">&#x27;arrow-parens&#x27;</span>: [<span class="string">&quot;error&quot;</span>, <span class="string">&quot;as-needed&quot;</span>], <span class="comment">// 箭头函数优先不使用()</span></span><br><span class="line">  <span class="string">&#x27;arrow-body-style&#x27;</span>: [<span class="string">&quot;error&quot;</span>, <span class="string">&quot;as-needed&quot;</span>], <span class="comment">// 箭头函数函数体使用&#123;&#125;，视情况而定，如果纯返回值，则禁用大括号和return语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义脚手架</title>
    <url>/2022/09/30/custom-cli/</url>
    <content><![CDATA[<h2 id="自定义cli"><a href="#自定义cli" class="headerlink" title="自定义cli"></a>自定义cli</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>先使用npm 或者 yarn，完成package.json 的创建，命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn init -y </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是默认配置，你也可以不用-y，然后按照它的提示一步一步往下走</span></span><br></pre></td></tr></table></figure>

<p>然后添加命令行入口文件，我是在根目录下建立 <code>cli</code> 文件夹，并添加 <code>index.js</code>，可以先随便写一些内容如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cli start&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这时候我们用node去执行，看看是否有输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node ./cli/index</span><br></pre></td></tr></table></figure>

<p>可以看到确实有输出，但是如何用命令行形式将其输出？例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">希望这样的命令行，就能将index.js内容输出</span></span><br><span class="line">jacky</span><br></pre></td></tr></table></figure>

<p>接下来就是生成自定义的cli，很简单其实，往下看</p>
<h3 id="cli生成"><a href="#cli生成" class="headerlink" title="cli生成"></a>cli生成</h3><p>找到package.json，添加bin字段，并对应配置，如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jacky&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./cli/index.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>意思就是，定义一个cli命令，并且指定其入口执行js文件</p>
<p>接下来就是，将这个命令链接到全局，我们能够在任何目录下通过这个命令来执行 <code>cli/index.js</code>中的代码<br>操作如下，在项目根目录，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure>

<p>这个时候我们可以查看是否cli命令行已经生成了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm list -g</span><br></pre></td></tr></table></figure>

<p>这是我们可以尝试在命令行里执行 jakcy，看看有没有反应，结果肯定是报错，因为我们的入口文件，需要指定在node环境下运行，就需要在该文件头部定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!usr/bin/env node</span><br></pre></td></tr></table></figure>

<p>这样就能够让代码正确运行在node环境，重新执行jacky命令，终端就会输出index.js 内容</p>
<blockquote>
<p>需要注意，如果添加头部配置后，重新执行命令依然报错，可以先解除命令，在根目录执行 <code>npm unlink jacky-cli</code>,然后全局卸载掉 <code>npm uninstall jacky-cli</code>, 然后重新 <code>npm link</code>, 这样重新走一遍流程就能解决了</p>
</blockquote>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>上面我们介绍了 cli 的最基本配置过程，那么用户在使用 cli 的时候，肯定会有参数支持，例如 vite 支持 –template，rollup 支持 –output，这些就是参数，也就是让命令行走不同的逻辑分支，完成不同功能。</p>
<h4 id="安装commander依赖"><a href="#安装commander依赖" class="headerlink" title="安装commander依赖"></a>安装commander依赖</h4><p><code>commander</code> 是一款解决命令行问题的npm包，大部分脚手架工具都会安装这个包，安装它的目的就是帮助我们去处理输入的命令参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i commander</span><br></pre></td></tr></table></figure>

<p>然后我们可以在 index.js 中添加内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要从包里导出program对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; program &#125; = <span class="built_in">require</span>(<span class="string">&quot;commander&quot;</span>);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">command</span>(<span class="string">&#x27;init&#x27;</span>) <span class="comment">// 配置命令 =&gt; jacky init</span></span><br><span class="line">  .<span class="title function_">option</span>(<span class="string">&#x27;--type &lt;char&gt;&#x27;</span>, <span class="string">&#x27;input your type&#x27;</span>, <span class="string">&#x27;vue&#x27;</span>) <span class="comment">// 配置参数 =&gt; jacky init --type react</span></span><br><span class="line">  .<span class="title function_">action</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    <span class="comment">// &#123; type: &#x27;react&#x27; &#125;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析输入的命令参数</span></span><br><span class="line">program.<span class="title function_">parse</span>(process.<span class="property">argv</span>)</span><br></pre></td></tr></table></figure>

<p>commander 包提供了一个 program 的对象，方便我们快速地对命令行内容操作和配置，当然它内部还提供了更强大的功能，有兴趣可以移步官网<br>这里重点介绍program对象</p>
<ul>
<li>command方法，定义命令名称，配置后会生成如，<code>jacky init</code>的命令</li>
<li>option方法，定义命令参数，是针对上述命令完成进一步配置的，可设置多个option，可以接受三个参数<ul>
<li>参数1，参数名称和类型，必填</li>
<li>参数2，参数类型说明，可选</li>
<li>参数3，参数默认值，可选</li>
</ul>
</li>
<li>action方法，在输入完命令后的回调函数，接收的参数就是输入的命令内容组成的对象</li>
</ul>
<h4 id="安装inquirer依赖"><a href="#安装inquirer依赖" class="headerlink" title="安装inquirer依赖"></a>安装inquirer依赖</h4><p>inquirer是提供给用户在命令行交互的包，例如询问，输入，选择等多种交互方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i inquirer</span><br></pre></td></tr></table></figure>

<p>然后我们在index.js 中再添加一条命令，并且加入交互操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">program</span><br><span class="line">  .<span class="title function_">command</span>(<span class="string">&#x27;create&#x27;</span>)</span><br><span class="line">  .<span class="title function_">action</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">prompt</span>([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>, <span class="comment">// 交互类型，输入形式</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>, <span class="comment">// 字段名称</span></span><br><span class="line">        <span class="attr">default</span>: <span class="string">&#x27;jacky cheung&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;please input your name&#x27;</span> <span class="comment">// 交互信息</span></span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>然后我们敲下 <code>jacky create</code>, 终端会出现提示，然后我们输入一些内容，看看会是什么现象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS D:\JackyProgram\jacky-cli&gt; jacky create    </span><br><span class="line">? please input your name jacky cheung</span><br><span class="line">res:  &#123; name: &#x27;jacky cheung&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>打印的结果就是，将prompt配置的字段整合为一个对象，当然这里介绍的都是基本操作，更多的api请参考官网，这里是做铺垫为了后面的项目</p>
<p>propmt接受的是一个数组，也就是询问的条数</p>
<ul>
<li>type，交互类型，如 input, confirm, checkbox, list, number, password等</li>
<li>name，字段名称，也就是最终prompt的返回的结果，由这些字段组装而成</li>
<li>default，字段默认值，如果直接按回车，就以该值作为输入值</li>
<li>message，交互提示说明文字，在交互时会给予提示</li>
</ul>
<p>prompt本身返回一个promise，所以你可以使用 <code>async/await</code>，也可以使用 <code>.then</code> 形式做后续操作。</p>
<h2 id="实现Git规范"><a href="#实现Git规范" class="headerlink" title="实现Git规范"></a>实现Git规范</h2><p>前面的内容已经介绍了如何完成简单的cli，并且能够处理命令和交互，这一节我们讨论如何利用cli实现对git方面的提交约束</p>
<h3 id="jacky-git-命令"><a href="#jacky-git-命令" class="headerlink" title="jacky git 命令"></a>jacky git 命令</h3><p>我们期望有这样一个命令，<code>jacky git</code>，然后通过参数，完成对git规范的配置，配置git规范的流程见另一篇文章<br><a href="/2022/10/01/commit-lint-steps/">git提交规范定制流程</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>cli</tag>
      </tags>
  </entry>
  <entry>
    <title>ts声明文件</title>
    <url>/2022/10/16/ts-declare/</url>
    <content><![CDATA[<h2 id="d-ts介绍"><a href="#d-ts介绍" class="headerlink" title=".d.ts介绍"></a>.d.ts介绍</h2><p>.d.ts 一个作用是提供给js开发者，尤其是库的开发中，声明变量类型用的，因为在用js编写的代码中，是没有类型而言的，所以如果ts项目中，又引入了这些js文件，那么在使用中是肯定会报错的，看个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRandom</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> min + (max - min) * <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  getRandom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getRandom &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils/func&#x27;</span> <span class="comment">// 无法找到模块“./utils/func”的声明文件。“func.js”隐式拥有 &quot;any&quot; 类型。ts(7016)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = <span class="title function_">getRandom</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>这里直接在引用的时候就直接报错了，因为ts根本就识别不了这个js文件模块，那么这种情况就需要去写一个同名的 <code>func.d.ts</code>去实现</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">getRandom</span>(<span class="params">min: <span class="built_in">number</span>, max: <span class="built_in">number</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  getRandom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件的位置无所谓，ts会在项目中扫码，直到找到这个.d.ts为止，所以放在哪都行</p>
<h2 id="为外部js模块添加类型"><a href="#为外部js模块添加类型" class="headerlink" title="为外部js模块添加类型"></a>为外部js模块添加类型</h2><p>比如当你的项目中引入了 <code>demo.js</code>，这个js文件是从npm上下载的，但开发人员当初在编写代码时是使用的纯js，而你的项目是使用ts的，所以当你从这个库里面导入某些方法或变量时，ts会提示你没有这个模块，示例如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">&#x27;jQuery&#x27;</span> <span class="comment">// 无法找到模块“jQuery”的声明文件。“/node_modules/jQuery/dist/jquery.js”隐式拥有 &quot;any&quot; 类型。</span></span><br></pre></td></tr></table></figure>

<p>那么为了解决这种情况，就需要我们去添加一个包含 <code>declare module &#39;jQuery&#39;;</code> 的新声明(.d.ts)文件，文件名无所谓，ts会在所有.d.ts中寻找，是否存在这个模块，那么我们就添加一个这样的文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;jQuery&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url: <span class="built_in">string</span></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，前面的报错就没有了，我们可以正常地使用 jQuery 中 ajax 这个方法了，当然除了手动添加，目前市面上主流的一些js库都有了自己的.d.ts声明文件，可以尝试通过安装依赖 <code>npm i --save-dev @types/jquery</code>，如果存在则会load下来，就不必自行编写了</p>
<h2 id="全局定义类型和变量"><a href="#全局定义类型和变量" class="headerlink" title="全局定义类型和变量"></a>全局定义类型和变量</h2><p>在ts项目中，我们经常会编写类型，然后定义变量时去使用这些类型，但是如果我们想使用一些全局类型要怎么做？这种情况也可以利用.d.ts，去declare global，那么在全局项目中就能够去用这些类型而无需引入，案例如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">StrNum</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">const</span> jc = <span class="string">&#x27;jacky chueng&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局声明的类型必须是模块类型，所以至少需要export出去一个&#123;&#125;</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">str</span>: <span class="title class_">StrNum</span> = <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以完成全局的类型定义，但事实上，我们在任意的.d.ts中 declare 的变量或类型，都是能够在全局使用，所以不一定要定义在 global 里面</p>
<h2 id="访问window上的属性"><a href="#访问window上的属性" class="headerlink" title="访问window上的属性"></a>访问window上的属性</h2><p>例如，一个js库在window上拓展了一些方法，但如果直接使用，ts会提示window上不存在这个方法，所以需要利用 .d.ts 做一些扩展</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">log</span> = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;msg: &#x27;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 类型“Window &amp; typeof globalThis”上不存在属性“log”</span></span><br></pre></td></tr></table></figure>

<p>解决如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">  <span class="attr">log</span>: <span class="function">(<span class="params">msg: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样window中再访问log属性，就能够正常使用了</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>ts 中 is 关键字的用法</title>
    <url>/2022/10/20/ts-is/</url>
    <content><![CDATA[<p>is 可以看作一种特殊的 boolean 类型，并且用于函数的返回类型，先看一个例子</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;string type&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;number type&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">returnReq</span>(<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> req</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(val)) &#123;</span><br><span class="line">    req = &#123;</span><br><span class="line">      <span class="attr">len</span>: val.<span class="property">length</span> <span class="comment">// 类型“number”上不存在属性“length”。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    req = &#123;</span><br><span class="line">      <span class="attr">len</span>: val.<span class="title function_">toString</span>().<span class="property">length</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段code的意思是，isString用作是否为 string 的判断，returnReq 函数用作返回一个对象格式的报文，但这样的代码是会报错的，虽然 isString 函数限制了输入类型仅为 string 或 number，并且能准确返回值 true&#x2F;false，但是 ts 是在编译阶段起作用的，至于真正运行时是什么样子，是不知道的，所以即使isString函数没有问题，但是在尝试访问 val.length 时，val的类型依然时 string | number，所以number身上不存在 length，因此报错。</p>
<p>为了解决这个问题，is 就可以派上用场了，它的用法非常简单，只需要在函数的返回值后面加上 xx is yourType</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span></span>): val is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;string type&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;number type&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这样的话，在当 isString(val) 返回为 true 的情况下，val的类型就被约束成更精确的 string，否则将被推断成 number，所以后续对val.length 的操作就不会提示报错了</p>
<p>简单总结下</p>
<p>如果一个函数的参数被is限定了某种类型T，那么在当这个函数执行返回true的时候，这时参数的类型就是之前限定的T，反之就是除了T之外的类型，当然 is 的使用场景在实际中，可以被 as 断言去替换，所以使用的情况就因人而异了</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>TS 练习题</title>
    <url>/2022/10/08/ts-exercise/</url>
    <content><![CDATA[<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>本道题我们希望参数 a 和 b 的类型都是一致的，即 a 和 b 同时为 number 或 string 类型。当它们的类型不一致的值，TS 类型检查器能自动提示对应的错误信息。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  希望这个函数的两个参数可以传string类型，也可以传number类型</span></span><br><span class="line"><span class="comment">  1. 当都为string时候，作为字符串相加</span></span><br><span class="line"><span class="comment">  2. 当都为number时候，作为数字相加</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a: <span class="built_in">string</span> | <span class="built_in">number</span>, b: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">&#x27;:&#x27;</span> + b; <span class="comment">// no error but b can be number!</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// error as b can be number | string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法，函数重载，代码如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a: <span class="built_in">string</span> | <span class="built_in">number</span>, b: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">&#x27; : &#x27;</span> + b</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SetPartial工具类"><a href="#SetPartial工具类" class="headerlink" title="SetPartial工具类"></a>SetPartial工具类</h2><p>如何定义一个 SetPartial工具类 工具类型，支持把给定的keys对应的属性变成可选的？对应的使用示例如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Info</span> = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="built_in">number</span></span><br><span class="line"> b?: <span class="built_in">string</span></span><br><span class="line"> <span class="attr">c</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OInfo</span> = <span class="title class_">SetPartial</span>&lt;<span class="title class_">Info</span>, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type OInfo = &#123;</span></span><br><span class="line"><span class="comment">//  a?: number; // 可选的</span></span><br><span class="line"><span class="comment">//  b?: string; // 保持不变继续可选</span></span><br><span class="line"><span class="comment">//  c: boolean; </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>解决思路是，先用 <code>Omit</code> 工具将其余属性取出来形成 A 类型，然后用 <code>Pick</code> 工具将目标属性取出来并且使用 <code>Partial</code> 将其改造为全部可选，形成 B 类型，然后利用交叉运算 A &amp; B，即可得到最终结果，代码如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SetPartial</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Omit</span>&lt;T, K&gt; &amp; <span class="title class_">Partial</span>&lt;<span class="title class_">Pick</span>&lt;T, K&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="SetRequired工具类"><a href="#SetRequired工具类" class="headerlink" title="SetRequired工具类"></a>SetRequired工具类</h2><p>如何定义一个 SetRequired 工具类 工具类型，支持把给定的keys对应的属性变成必选的,对应的使用示例如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Info</span> = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="built_in">number</span></span><br><span class="line"> b?: <span class="built_in">string</span></span><br><span class="line"> c?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OInfo</span> = <span class="title class_">SetPartial</span>&lt;<span class="title class_">Info</span>, <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type OInfo = &#123;</span></span><br><span class="line"><span class="comment">//  a: number; // 保持不变继续必选</span></span><br><span class="line"><span class="comment">//  b: string; // 改为必选</span></span><br><span class="line"><span class="comment">//  c: boolean; // 改为必选</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>和上面那道思路完全一致，只不过将 <code>Partial</code> 换成另一个工具类 <code>Required</code> 即可，代码如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SetRequired</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Omit</span>&lt;T, K&gt; &amp; <span class="title class_">Required</span>&lt;<span class="title class_">Pick</span>&lt;T, K&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="AppendArg工具类"><a href="#AppendArg工具类" class="headerlink" title="AppendArg工具类"></a>AppendArg工具类</h2><p>定义一个工具类型 AppendArg，为已有的函数类型增加指定类型的参数，新增的参数名是x，将作为新函数类型的第一个参数。具体的使用示例如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AppendArg</span>&lt;F, A&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FnPlus</span> = <span class="title class_">AppendArg</span>&lt;<span class="title class_">Fn</span>, <span class="built_in">boolean</span>&gt; </span><br><span class="line"><span class="comment">// (x: boolean, a: number, b: string) =&gt; number</span></span><br></pre></td></tr></table></figure>

<p>这道题有两种思路可以解决，下面分别介绍</p>
<h3 id="利用-ReturnType-和-Parameters-结合使用"><a href="#利用-ReturnType-和-Parameters-结合使用" class="headerlink" title="利用 ReturnType 和 Parameters 结合使用"></a>利用 ReturnType 和 Parameters 结合使用</h3><blockquote>
<p>ReturnType 是用来获取一个函数的返回值，Parameters 是用来获取一个函数的参数类型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AppendArg</span>&lt;F <span class="keyword">extends</span> (...<span class="attr">arg</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>, T&gt; = </span><br><span class="line"><span class="function">(<span class="params">x: T, ...arg: Parameters&lt;F&gt;</span>) =&gt;</span> <span class="title class_">ReturnType</span>&lt;F&gt;</span><br></pre></td></tr></table></figure>

<h3 id="利用-infer-来实现"><a href="#利用-infer-来实现" class="headerlink" title="利用 infer 来实现"></a>利用 infer 来实现</h3><blockquote>
<p>infe 是当你不知道具体某种类型时，用来推到类型的，具体参考官网介绍</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AppendArgPlus</span>&lt;F <span class="keyword">extends</span> (...<span class="attr">arg</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>, T&gt; = </span><br><span class="line">F <span class="keyword">extends</span> (...<span class="attr">arg</span>: infer <span class="title class_">Arg</span>) =&gt; infer <span class="title class_">Return</span> ? </span><br><span class="line"><span class="function">(<span class="params">x: T, ...arg: Arg</span>) =&gt;</span> <span class="title class_">Return</span> </span><br><span class="line">: <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h2 id="NoEmptyArray-工具类"><a href="#NoEmptyArray-工具类" class="headerlink" title="NoEmptyArray 工具类"></a>NoEmptyArray 工具类</h2><p>定义 NoEmptyArray 工具类型，用于确保数据非空数组。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NoEmptyArray</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="title class_">NoEmptyArray</span>&lt;<span class="built_in">string</span>&gt; = [] <span class="comment">// 将出现编译错误</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">NoEmptyArray</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;Hello TS&#x27;</span>] <span class="comment">// 非空数据，正常使用</span></span><br></pre></td></tr></table></figure>

<p>思路，先设定一个数组，第一位就是 T 类型，其余位置为可选拓展运算并且类型也为 T 的数组，代码如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NoEmptyArrays</span>&lt;T&gt; = [T, ...<span class="title class_">Array</span>&lt;T&gt;]</span><br></pre></td></tr></table></figure>

<h2 id="Trim-工具类型"><a href="#Trim-工具类型" class="headerlink" title="Trim 工具类型"></a>Trim 工具类型</h2><p>实现一个Trim工具类型，用于对字符串字面量类型进行消除收尾空格处理</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Trim</span>&lt;V <span class="keyword">extends</span> <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="title class_">Trim</span>&lt;<span class="string">&#x27; jackycheung &#x27;</span>&gt;</span><br><span class="line"><span class="comment">//=&gt; &#x27;jackycheung&#x27;</span></span><br></pre></td></tr></table></figure>

<p>解题思路，需要一个左侧trim工具和一个右侧清除工具，并且结合 infer 推断，利用递归思想解决</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  左侧清除工具</span></span><br><span class="line"><span class="comment">  1. 如果左侧有空格，先推导出去掉一个左侧空格后的类型L</span></span><br><span class="line"><span class="comment">  2. 继续递归对L进行去除左侧</span></span><br><span class="line"><span class="comment">  3. 直到左侧没有空格，返回L</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  右侧清除工具的思路和左侧完全一致，所以整个的 Trim 类型就是将类型 S 交给左侧后再交给右侧，或者反过来先右后左，都一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TrimL</span>&lt;S&gt; = S <span class="keyword">extends</span> <span class="string">` <span class="subst">$&#123;infer L&#125;</span>`</span> ? <span class="title class_">TrimL</span>&lt;L&gt; : S</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TrimR</span>&lt;S&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer R&#125;</span> `</span> ? <span class="title class_">TrimR</span>&lt;R&gt; : S</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Trim</span>&lt;S&gt; = <span class="title class_">TrimR</span>&lt;<span class="title class_">TrimL</span>&lt;S&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Unshift-工具类型"><a href="#Unshift-工具类型" class="headerlink" title="Unshift 工具类型"></a>Unshift 工具类型</h2><p>实现一个 Unshift 工具类型，用于把指定类型 E 作为第一个元素添加到 T 数组类型中。具体的使用示例如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Unshift</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; =  <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arr0</span> = <span class="title class_">Unshift</span>&lt;[], <span class="number">1</span>&gt;; <span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arr1</span> = <span class="title class_">Unshift</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>&gt;; <span class="comment">// [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>思路，利用 infer 推断出 T 的成员类型，然后在头部加入新类型即可，如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Unshift</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = T <span class="keyword">extends</span> [...infer L] ? [E, ...L] : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h2 id="Shift-工具类型"><a href="#Shift-工具类型" class="headerlink" title="Shift 工具类型"></a>Shift 工具类型</h2><p>实现一个 Shift 工具类型，用于移除 T 数组类型中的第一个类型。具体的使用示例如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shift</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S0</span> = <span class="title class_">Shift</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt; <span class="comment">// [2, 3]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">Shift</span>&lt;[<span class="built_in">string</span>,<span class="built_in">number</span>,<span class="built_in">boolean</span>]&gt; <span class="comment">// [number,boolean]</span></span><br></pre></td></tr></table></figure>

<p>思路，和 Unshift 一致，利用 infer 推断出第一个元素类型，和剩余元素类型，直接返回剩余类型即可，如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shift</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer F, ...infer R] ? R : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h2 id="Push-工具类型"><a href="#Push-工具类型" class="headerlink" title="Push 工具类型"></a>Push 工具类型</h2><p>实现一个 Push 工具类型，用于把指定类型 E 作为最后一个元素添加到 T 数组类型中。具体的使用示例如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Push</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], V&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arr0</span> = <span class="title class_">Push</span>&lt;[], <span class="number">1</span>&gt; <span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arr1</span> = <span class="title class_">Push</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>&gt; <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>思路，和 Unshift 一样，先推断类型，然后将目标类型加到尾部即可</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Push</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = T <span class="keyword">extends</span> [...infer R] ? [...R, E] : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h2 id="Pop-工具类型"><a href="#Pop-工具类型" class="headerlink" title="Pop 工具类型"></a>Pop 工具类型</h2><p>实现一个 Pop 工具类型，用于移除 T 数组类型中的最后一个类型。具体的使用示例如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Pop</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S0</span> = <span class="title class_">Pop</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt; <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">Pop</span>&lt;[<span class="built_in">string</span>,<span class="built_in">number</span>,<span class="built_in">boolean</span>]&gt; <span class="comment">// [string,number]</span></span><br></pre></td></tr></table></figure>

<p>思路，和 Shift 一样，先推断出最后一个之前的元素类型，和最后一个元素类型，返回前面的即可，如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Pop</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...infer R, infer L] ? [...R] : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h2 id="Include工具类型"><a href="#Include工具类型" class="headerlink" title="Include工具类型"></a>Include工具类型</h2><p>实现一个 Includes 工具类型，用于判断指定的类型 E 是否包含在 T 数组类型中。具体的使用示例如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt;, E&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">Includes</span>&lt;[], <span class="number">1</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Includes</span>&lt;[<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>], <span class="number">2</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">Includes</span>&lt;[<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>], <span class="number">1</span>&gt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>思路，这里需要一个辅助类型 ArrToUnion，也就是将数组转为联合类型，然后就可以判断目标类型是否继承自这个联合类型<br>而实现 ArrToUnion 的思路则是 infer 推断结合递归，以此取出第一个类型后，联合上递归剩余类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ArrToUnion</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer F, ...infer R] ?</span><br><span class="line">F | <span class="title class_">ArrToUnion</span>&lt;R&gt; : <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Include</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = T <span class="keyword">extends</span> [...infer R] ? </span><br><span class="line">E <span class="keyword">extends</span> <span class="title class_">ArrToUnion</span>&lt;[...R]&gt; ? <span class="attr">true</span>: <span class="literal">false</span></span><br><span class="line">: <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h2 id="Curry-工具类型"><a href="#Curry-工具类型" class="headerlink" title="Curry 工具类型"></a>Curry 工具类型</h2><p>实现一个 Curry 工具类型，用来实现函数类型的柯里化处理。具体的使用示例如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Curry</span>&lt;</span><br><span class="line">  F <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">any</span>[] = <span class="title class_">Parameters</span>&lt;F&gt;, </span><br><span class="line">  R = <span class="title class_">ReturnType</span>&lt;F&gt; </span><br><span class="line">&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F0</span> = <span class="title class_">Curry</span>&lt;<span class="function">() =&gt;</span> <span class="title class_">Date</span>&gt;; <span class="comment">// () =&gt; Date</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="title class_">Curry</span>&lt;<span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="title class_">Date</span>&gt;; <span class="comment">// (arg: number) =&gt; Date</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="title class_">Curry</span>&lt;<span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="title class_">Date</span>&gt;; <span class="comment">//  (arg_0: number) =&gt; (b: string) =&gt; Date</span></span><br></pre></td></tr></table></figure>

<p>思路，需要利用 infer 推断出函数类型中的参数类型 arg 和返回类型 return，其中 arg 类型应该拆开，看是否有第一位和剩余位数,如果第一位都没有，直接返回无参数的函数类型，其返回值为 return类型；如果有第一位，则返回带参数的函数类型，继续对剩余参数做递归判断，具体实现代码如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Curry</span>&lt;</span><br><span class="line">  F <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>,</span><br><span class="line">&gt; = F <span class="keyword">extends</span> (...<span class="attr">arg</span>: [infer A, ...infer R]) =&gt; infer <span class="title class_">Return</span> ?</span><br><span class="line">(</span><br><span class="line">  <span class="built_in">unknown</span> <span class="keyword">extends</span> A ?</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title class_">Return</span> :</span><br><span class="line">  <span class="function">(<span class="params">arg: A</span>) =&gt;</span> (</span><br><span class="line">    R <span class="keyword">extends</span> [infer F, ...infer L] ?</span><br><span class="line">    <span class="title class_">Curry</span>&lt;<span class="function">(<span class="params">...arg: [...R]</span>) =&gt;</span> <span class="title class_">Return</span>&gt;</span><br><span class="line">    : <span class="title class_">Return</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="实现Pick工具类"><a href="#实现Pick工具类" class="headerlink" title="实现Pick工具类"></a>实现Pick工具类</h2><p>在 ts 中有很多内置的工具，Pick是其中之一，作用是从一个对象接口或对象类型中，取出目标属性形成新的类型，如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> s = <span class="title class_">Pick</span>&lt;&#123;<span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span>&#125;, <span class="string">&#x27;a&#x27;</span>&gt;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  type s = &#123;</span></span><br><span class="line"><span class="comment">    a: string;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>思路，利用泛型特点，Pick是接受两个泛型，第二个泛型肯定是继承自第一个的泛型类型的所有key值，然后在形成新的类型时，遍历这些key值，并赋予对应的类型即可，实现如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyPick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> K]: T[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Record工具类"><a href="#实现Record工具类" class="headerlink" title="实现Record工具类"></a>实现Record工具类</h2><p>ts 中内置的 Recore 类型，作用是将指定属性名赋值目标类型，最后形成新的一个类型，如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> messi = <span class="title class_">Record</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="number">1</span>, <span class="built_in">number</span> | <span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">type messi = &#123;</span></span><br><span class="line"><span class="comment">    1: string | number;</span></span><br><span class="line"><span class="comment">    a: string | number;</span></span><br><span class="line"><span class="comment">    b: string | number;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>思路，和 Record 一致，也是利用泛型遍历，将第一个泛型的值遍历得到key，第二个泛型类型赋值给key即可，但需要注意，当使用 [k in K]的前提是，K 应该被限制在 string，number，symbol中，因为只有这三种类型才能被 [k in K] 这种语法遍历，如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyRecord</span>&lt;K <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">symbol</span>, T&gt; = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Merge工具类"><a href="#实现Merge工具类" class="headerlink" title="实现Merge工具类"></a>实现Merge工具类</h2><p>实现一个Merge工具类型，用于把两个类型合并成一个新的类型。第二种类型（SecondType）的Keys将会覆盖第一种类型（FirstType）的Keys。具体的使用示例如下所示</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123; </span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Merge</span>&lt;<span class="title class_">FirstType</span>, <span class="title class_">SecondType</span>&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">ab</span>: <span class="title class_">Merge</span>&lt;<span class="title class_">Foo</span>, <span class="title class_">Bar</span>&gt; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路，merge这个工具有点像平时使用的交叉类型，但不同的是，交叉类型如果遇到某个属性是不同类型的，那么交叉过后该属性类型为 never，而merge的工具则是让后面的类型覆盖前面的类型，就和js中 <code>Object.assign</code> 一样合并，只不过ts合并的是类型，那我们实现的步骤应该如下</p>
<ol>
<li>先遍历 FirstType 的 key</li>
<li>判断 key 是否也存在与 SecondType 上</li>
<li>如果是，则使用 <code>SecondType[key]</code> 作为最终类型，否则就说明该 key 不存在SecondType，就继续使用原 FirstType[key]</li>
<li>从 SecondType 中剔除 FirstType 的key，因为已经遍历过一遍了</li>
<li>将第3步和第4步得到的类型做交叉运算</li>
</ol>
<p>实现如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Merge</span>&lt;<span class="title class_">FirstType</span>, <span class="title class_">SecondType</span>&gt; = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> keyof <span class="title class_">FirstType</span>]: k <span class="keyword">extends</span> keyof <span class="title class_">SecondType</span></span><br><span class="line">    ? <span class="title class_">SecondType</span>[k]</span><br><span class="line">    : <span class="title class_">FirstType</span>[k]</span><br><span class="line">&#125; &amp; <span class="title class_">Omit</span>&lt;<span class="title class_">SecondType</span>, keyof <span class="title class_">FirstType</span>&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本身还可以省略一步，就是直接将第三步得到的类型 FirstTypePlus &amp; SecondType，因为FirstTypePlus已经包含了公共的类型且类型值已经是SecondType中的，直接做交叉运算也是可以，但不够优雅</p>
</blockquote>
<h2 id="RemoveNever工具类"><a href="#RemoveNever工具类" class="headerlink" title="RemoveNever工具类"></a>RemoveNever工具类</h2><p>实现一个 RemoveNever 工具，能够将一个类型上的 never类型值去掉只保留其他值</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RemoveNever</span>&lt;T&gt; = <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Messi</span> = &#123;</span><br><span class="line">  <span class="attr">speed</span>: <span class="number">99</span>,</span><br><span class="line">  <span class="attr">shoot</span>: <span class="number">99</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">never</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CleanNever</span> = <span class="title class_">RemoveNever</span>&lt;<span class="title class_">Messi</span>&gt; </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    speed: 99,</span></span><br><span class="line"><span class="comment">    shoot: 99,</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里需要利用到ts中 keyof 的用法，keyof是用来获取一个类型的键的联合类型，例如</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Messi</span> = &#123;</span><br><span class="line">  <span class="attr">speed</span>: <span class="number">99</span>,</span><br><span class="line">  <span class="attr">shoot</span>: <span class="number">99</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">never</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> keys = keyof <span class="title class_">Messi</span> <span class="comment">// &#x27;speed&#x27; | &#x27;shoot&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果我们通过 Messi[‘age’] 访问一个类型，得到的是对应的类型值 never，而 never | ‘speed’ 的结果是 ‘speed’，根据这个特性，我们的思路就应该是</p>
<ol>
<li>遍历类型的键，如果对应值不为never，则赋值类型值为key本身，如果是never，赋值为never</li>
<li>第一步之后得到的类型就是除never类型之外的键值对都是一致的，即 key &#x3D;&#x3D; value</li>
<li>利用 Type[key of type], 获取到所有键对应值的联合类型，但由于never做联合类型后会消失，所以保留了其他键的集合</li>
<li>利用Pick将上一步得到的键集合筛选出来</li>
</ol>
<p>实现如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RemoveNever</span>&lt;T&gt; = <span class="title class_">Pick</span>&lt;T, &#123;</span><br><span class="line">  [k <span class="keyword">in</span> keyof T]: T[k] <span class="keyword">extends</span> <span class="built_in">never</span> ? <span class="built_in">never</span> : k</span><br><span class="line">&#125;[keyof T]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h2 id="PickPartial-工具类"><a href="#PickPartial-工具类" class="headerlink" title="PickPartial 工具类"></a>PickPartial 工具类</h2><p>实现一个 PickPartial 工具类型，用来获取对象类型中声明的可选属性。具体的使用示例如下所示</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">from</span>?: <span class="built_in">string</span>;</span><br><span class="line">  speak?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PickPartial</span>&lt;T&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonOptionalKeys</span> = <span class="title class_">PickPartial</span>&lt;<span class="title class_">Person</span>&gt; <span class="comment">// &quot;from&quot; | &quot;speak&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里需要一个技巧点，当一个属性是可选的，那么这个属性的类型是声明类型 | undefined，那么就可以根据这个特点，判断undefined是否继承该类型值</p>
<ol>
<li>遍历对象类型，判断 undefined extends 每一个键值类型</li>
<li>如果是，则赋值为键key本身，并强制赋值为必选属性 -?</li>
<li>否则，赋值为never</li>
<li>此时得到的新类型是，原可选类型一律赋值为key本身且必选，原必选类型全为never</li>
<li>继续利用 {}[keyof T]，过滤掉never，得到就是原可选键集合</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PickPartial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> keyof T]-?: <span class="literal">undefined</span> <span class="keyword">extends</span> T[k]</span><br><span class="line">    ? T[k] <span class="keyword">extends</span> <span class="literal">undefined</span></span><br><span class="line">      ? <span class="built_in">never</span></span><br><span class="line">      : k</span><br><span class="line">    : <span class="built_in">never</span></span><br><span class="line">&#125;[keyof T]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但这样还是会有一个小问题，如果某个值是可选，但类型为undefined，此时是无法将这个k给选出来的，但这样声明是毫无意义的，所以忽略</p>
</blockquote>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>ts总结 类型兼容性</title>
    <url>/2022/10/15/ts-type-compatible/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 ts 中，变量常常是和类型并存的，当你声明一个变量（如对象）时候，如果已经对这个变量的类型下了定义，那么这个变量的值就必须遵循对应类型的规则，否则 ts 将提示错误信息，如下示例</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">Info</span> = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;hello ts&#x27;</span>,</span><br><span class="line">  <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  var Date: DateConstructor</span></span><br><span class="line"><span class="comment">  Enables basic storage and retrieval of dates and times.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  不能将类型“&#123; msg: string; time: number; &#125;”分配给类型“Info”。</span></span><br><span class="line"><span class="comment">  对象文字可以只指定已知属性，并且“time”不在类型“Info”中。ts(2322)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上述代码会报错，因为我们没有定义的 Info 接口里没有声明 time 属性，而赋值时却多出来了这个属性，那么假如就有这么一个场景，例如前端定义的某个对象的形状 Info 就是这样的，但是传递给后端的数据 在 Info 基础需要上多出来某些属性如time的时间戳，如果要实现直接赋值，则会出现上述报错，那么有什么办法可以做到呢？</p>
<h2 id="对象类型兼容性"><a href="#对象类型兼容性" class="headerlink" title="对象类型兼容性"></a>对象类型兼容性</h2><p>前面这个问题，就是本节讨论的类型兼容性，我们虽然不能直接将多出来的属性赋值给目标type，但是可以做一点小小的改动，如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;hello ts&#x27;</span>,</span><br><span class="line">  <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">Info</span> = obj</span><br></pre></td></tr></table></figure>

<p>就像这样，我们利用一个中间对象作为桥梁就可以完成赋值了，而前面的报错则是我们直接使用的对象字面量方法的赋值，当一个对象 A 完全 包含 B 的所有属性时，那么就可以说 B 兼容了 A，这个话听着可能会绕，再简洁一点就是，类型多的可以赋值给类型少的，类型少的兼容类型多的，注意，这里说的类型多少，是建立在一方完全包含另一方基础上的。</p>
<h2 id="class-类型兼容性"><a href="#class-类型兼容性" class="headerlink" title="class 类型兼容性"></a>class 类型兼容性</h2><p>我们知道，ts 中 class 也能充当接口作用，那么 class 之间的兼容性关系是如何的？</p>
<h3 id="public-属性"><a href="#public-属性" class="headerlink" title="public 属性"></a>public 属性</h3><p>对于 public 属性，就和 interface 一样，在包含关系基础上，类型多的可以赋值给类型少的，如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class1</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class2</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">c1</span>: <span class="title class_">Class1</span> = <span class="keyword">new</span> <span class="title class_">Class1</span>()</span><br><span class="line"><span class="keyword">var</span> <span class="attr">c2</span>: <span class="title class_">Class2</span> = <span class="keyword">new</span> <span class="title class_">Class2</span>()</span><br><span class="line"></span><br><span class="line">c2 = c1 <span class="comment">// 报错，类型 &quot;Class1&quot; 中缺少属性 &quot;num&quot;，但类型 &quot;Class2&quot; 中需要该属性</span></span><br><span class="line">c1 = c2</span><br></pre></td></tr></table></figure>

<h3 id="private-和-protect"><a href="#private-和-protect" class="headerlink" title="private 和 protect"></a>private 和 protect</h3><p>如果类里面的属性不是 public，那么在兼容性方面就会不同，如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class1</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class2</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">c1</span>: <span class="title class_">Class1</span> = <span class="keyword">new</span> <span class="title class_">Class1</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="attr">c2</span>: <span class="title class_">Class2</span> = <span class="keyword">new</span> <span class="title class_">Class2</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c2 = c1 <span class="comment">// 报错 不能将类型“Class1”分配给类型“Class2”。类型具有私有属性“name”的单独声明。</span></span><br><span class="line">c1 = c2 <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>可以看到，即使两个 class 完全一致，但均无法互相赋值，所以在 class 中但凡存在一个非public属性，都不能兼容对方</p>
<p>class 兼容性还有一个特点，不会检测 constructor</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class1</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class2</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">arg?: &#123; num: <span class="built_in">number</span>, names: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = arg?.<span class="property">names</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">c1</span>: <span class="title class_">Class1</span> = <span class="keyword">new</span> <span class="title class_">Class1</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="attr">c2</span>: <span class="title class_">Class2</span> = <span class="keyword">new</span> <span class="title class_">Class2</span>()</span><br><span class="line"></span><br><span class="line">c2 = c1</span><br><span class="line">c1 = c2</span><br></pre></td></tr></table></figure>

<p>上面两个互相赋值都没问题，因为都拥有相同的public属性name，虽然 constructor不同，但ts在兼容性方面跳过了构造函数</p>
<h2 id="函数兼容性"><a href="#函数兼容性" class="headerlink" title="函数兼容性"></a>函数兼容性</h2><p>是否能将一个函数赋值给另一个函数，也取决与它们之间的兼容性，看一个栗子</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">f1</span>: f1 = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">f2</span>: f2 = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1 = f2 <span class="comment">// 正常</span></span><br><span class="line">f2 = f1 <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>当 f1 赋值 给 f2 的时候，出现了报错，而反过来则是正常的，这是因为在函数的兼容性方面，参考的是其接收参数和返回值类型共同决定的</p>
<ol>
<li>返回值类型是否兼容， 如果要 f1 &#x3D; f2 成功，f2 的 ReturnType 需要和 f1 的相同或者是 f1 的 ReturnType的子类</li>
<li>参数个数，这里就和对象以及class相反了，较少的参数 f2 可以赋值给较多参数的 f1，所以在函数参数方面，较多的参数函数兼容较少的参数函数，这里讨论的基础是，当参数的类型是相同的</li>
<li>当参数个数相同，当对应的类型不同，比如都是对象类型，那么就继续看参数的类型是否满足兼容性，属性多的兼容属性少的，看个例子</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: &#123; name: <span class="built_in">string</span> &#125;</span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: &#123; name: <span class="built_in">string</span>, age: <span class="built_in">number</span> &#125;</span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">f1</span>: f1 = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: &#123; name: <span class="built_in">string</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">f2</span>: f2 = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1 = f2 <span class="comment">// 报错</span></span><br><span class="line">f2 = f1 <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure>

<p>上述案例在 f1 &#x3D; f2时，会报错，在参数方面个数都一样且第一位类型相同，而第二位y，在f2中的y类型要多于f1中的y类型，所以 f1 只能赋值给 f2</p>
<h2 id="数组兼容性"><a href="#数组兼容性" class="headerlink" title="数组兼容性"></a>数组兼容性</h2><p>在数组方面，兼容性则比较简单了，就是看数组的类型是否能兼容另一种类型，更直接一点就是，A 类型能否分配给 B类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Arr</span> = <span class="title class_">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arr2</span> = <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="title class_">Arr</span> = [<span class="number">1</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> <span class="attr">arr2</span>: <span class="title class_">Arr2</span> = []</span><br><span class="line"></span><br><span class="line">arr = arr2</span><br><span class="line">arr2 = arr <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>当 arr 赋值给 arr2 时，会出现报错，因为 string 类型不能分配给 number | string</p>
<p>最后说一个特殊情况，不管那种兼容性问题，当出现了 any 类型的话，就能够互相赋值，不存在兼容性问题了</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">s</span>: <span class="built_in">any</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">s1</span>: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">s = s1 <span class="comment">// ok</span></span><br><span class="line">s1 = s <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arr</span> = <span class="title class_">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arr2</span> = <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="title class_">Arr</span> = [<span class="number">1</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> <span class="attr">arr2</span>: <span class="title class_">Arr2</span> = []</span><br><span class="line">arr = arr2 <span class="comment">// ok</span></span><br><span class="line">arr2 = arr <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class1</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class2</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">arg?: &#123; num: <span class="built_in">number</span>, names: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = arg?.<span class="property">names</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">c1</span>: <span class="title class_">Class1</span> = <span class="keyword">new</span> <span class="title class_">Class1</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="attr">c2</span>: <span class="title class_">Class2</span> = <span class="keyword">new</span> <span class="title class_">Class2</span>()</span><br><span class="line"></span><br><span class="line">c2 = c1 <span class="comment">// ok</span></span><br><span class="line">c1 = c2 <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: &#123; name: <span class="built_in">string</span> &#125;</span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">f1</span>: f1 = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: &#123; name: <span class="built_in">string</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">f2</span>: f2 = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2 = f1 <span class="comment">// ok</span></span><br><span class="line">f1 = f2 <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>Vite 性能优化</title>
    <url>/2022/09/29/vite/</url>
    <content><![CDATA[<h2 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h2><p>使用 <a href="https://github.com/vbenjs/vite-plugin-compression/blob/main/README.zh_CN.md">vite-plugin-compression</a> 插件，该插件可以将源码资源根据配置需求进行压缩，生成gz压缩文件，在服务端传送方面提高效率，同时服务端在收到客户端请求的时候，也可以选择这些已经上传好了的gz文件，返回给浏览器自行解压。</p>
<h3 id="使用方式如下"><a href="#使用方式如下" class="headerlink" title="使用方式如下"></a>使用方式如下</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add vite-plugin-compression -D</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> viteCompression <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-compression&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugin</span>: [</span><br><span class="line">    <span class="title function_">viteCompression</span>(&#123;</span><br><span class="line">      <span class="attr">verbose</span>: <span class="literal">true</span>, <span class="comment">// 是否在控制台输出压缩日志</span></span><br><span class="line">      <span class="title function_">filter</span>(<span class="params">file</span>) &#123; <span class="comment">// 筛选哪些需要压缩的文件</span></span><br><span class="line">        <span class="comment">// 忽略css文件</span></span><br><span class="line">        <span class="keyword">return</span> !file.<span class="title function_">endsWith</span>(<span class="string">&#x27;.css&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">threshold</span>: <span class="number">50</span> * <span class="number">1024</span>, <span class="comment">// 压缩阈值，大于设定值需要压缩</span></span><br><span class="line">      <span class="attr">deleteOriginFile</span>: <span class="literal">false</span>, <span class="comment">// 压缩后是否删除源文件</span></span><br><span class="line">      <span class="attr">disable</span>: <span class="literal">false</span>, <span class="comment">// 是否禁用该插件</span></span><br><span class="line">      <span class="attr">ext</span>: <span class="string">&#x27;.gz&#x27;</span>, <span class="comment">// 压缩文件的后缀名</span></span><br><span class="line">      <span class="attr">algorithm</span>: <span class="string">&#x27;gzip&#x27;</span> <span class="comment">// 压缩算法，可选值参考文档</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="打包分析工具"><a href="#打包分析工具" class="headerlink" title="打包分析工具"></a>打包分析工具</h2><p>安装 <a href="https://github.com/btd/rollup-plugin-visualizer">rollup-plugin-visualizer</a>, 这是一款rollup打包分析插件，因为 vite 本身在构建阶段采用的就是 rollup，所以这个插件是依赖 rollup 的，大家不要与 webpack 打包的分析插件搞混淆了。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add rollup-plugin-visualizer -D</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该插件在打包时生效，并且在构建结束后，在根目录下默认生成states.html，打开这个html可以看到各种产物的情况</span></span><br><span class="line"><span class="keyword">import</span> &#123; visualizer &#125; <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-visualizer&#x27;</span></span><br><span class="line"><span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugin</span>: [</span><br><span class="line">    <span class="title function_">visualizer</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;data.html&#x27;</span>, <span class="comment">// 分析文件的文件名，默认states.html</span></span><br><span class="line">      <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 是否构建后自动打开分析的html</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;treemap&#x27;</span>, <span class="comment">// 分析模板，默认就是treemap也是最直观的，可选值见文档</span></span><br><span class="line">      <span class="comment">// ...其实默认调用visualizer函数就够了，具体的options配置可以参考文档根据自身需求来配置</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="第三方库用CDN方式引入"><a href="#第三方库用CDN方式引入" class="headerlink" title="第三方库用CDN方式引入"></a>第三方库用CDN方式引入</h2><p>在开发过程中，我们经常会引入一些第三方库，如 vue，但如果将其在构建阶段一并打包到产物中，那么体积可想而知，这时我们可以采用适当的CDN技术手段，将这些第三方库用 script 标签的形式从 CDN 引入，这样做的好处是，第一，构建产物体积减小了，效率方面有提高，第二，CDN可以缓存，第二次请求资源的时候，会利用强缓存或协商缓存，节约请求时间和资源。</p>
<h3 id="安装-vite-plugin-cdn-import"><a href="#安装-vite-plugin-cdn-import" class="headerlink" title="安装 vite-plugin-cdn-import"></a>安装 <a href="https://github.com/mmf-fe/vite-plugin-cdn-import#readme">vite-plugin-cdn-import</a></h3><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add vite-plugin-cdn-import -D</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importToCDN, &#123; autoComplete &#125; <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-cdn-import&#x27;</span></span><br><span class="line"><span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugin</span>: [</span><br><span class="line">    <span class="title function_">importToCDN</span>(&#123;</span><br><span class="line">      <span class="attr">modules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;react&#x27;</span>, <span class="comment">// 你要cdn形式的三方包名</span></span><br><span class="line">          <span class="attr">var</span>: <span class="string">&#x27;React&#x27;</span>, <span class="comment">// 该包暴露在全局的名称</span></span><br><span class="line">          <span class="attr">path</span>: <span class="string">`umd/react.production.min.js`</span>, <span class="comment">// 第三方CDN链接路径，可以是你自己的服务器上的路径</span></span><br><span class="line">          <span class="comment">// ...更多配置参考文档</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面这种方式适合自己灵活配置要求的开发人员，拥有自己的服务器，可以将源代码部署到上面的，因为你不知道开源的CDN资源什么时候会挂掉，但配置比较麻烦，如果你对自定义配置要求不多，可以考虑使用自动导入的方式，如下</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">importToCDN</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: [</span><br><span class="line">    <span class="title function_">autoComplete</span>(<span class="string">&#x27;vue&#x27;</span>),</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方式，会自动从你开发版本，也就是package.json中的版本号为准，然后生成对应的CDN链接的script标签</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当你使用了该插件，那么对应的第三方库，就不会打包到最终的产物里面</p>
</blockquote>
<h2 id="构建配置选项-build-options"><a href="#构建配置选项-build-options" class="headerlink" title="构建配置选项 build options"></a>构建配置选项 build options</h2><h3 id="assetsInlineLimit"><a href="#assetsInlineLimit" class="headerlink" title="assetsInlineLimit"></a>assetsInlineLimit</h3><ul>
<li>类型 number</li>
<li>默认值 4096 （4kb）</li>
</ul>
<p>小于此阈值的导入或引用资源将内联为 base64 编码，以避免额外的 http 请求。设置为 0 可以完全禁用此项</p>
<h3 id="cssCodeSplit"><a href="#cssCodeSplit" class="headerlink" title="cssCodeSplit"></a>cssCodeSplit</h3><ul>
<li>类型 boolean</li>
<li>默认值 true</li>
</ul>
<p>启用&#x2F;禁用 CSS 代码拆分。当启用时，在异步 chunk 中导入的 CSS 将内联到异步 chunk 本身，并在其被加载时插入。</p>
<p>如果禁用，整个项目中的所有 CSS 将被提取到一个 CSS 文件中。</p>
<h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><ul>
<li>类型 boolean</li>
<li>默认值 false</li>
</ul>
<p>是否开启源码映射，关闭后将不会生成 .map 文件，体积将会大幅减少，但根据实际情况，看你是否希望在生产环境定位问题。</p>
<h3 id="chunkSizeWarningLimit"><a href="#chunkSizeWarningLimit" class="headerlink" title="chunkSizeWarningLimit"></a>chunkSizeWarningLimit</h3><ul>
<li>类型 number</li>
<li>默认值 500 （500kb）</li>
</ul>
<p>当chunk的大小高于设定值后，触发警告，能够帮助你知道哪些chunk应该进一步拆分</p>
<h3 id="terserOptions"><a href="#terserOptions" class="headerlink" title="terserOptions"></a>terserOptions</h3><p>该配置主要是利用 terser 的打包模式，vite 默认采用的是 esBuild，所以使用 terser 模式，需要将 minify 配置为 terser，然后做进一步操作</p>
<ul>
<li>将开发环境下的log，debugger去除</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">terserOptions</span>: &#123;</span><br><span class="line">  <span class="attr">compress</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;drop_console&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;drop_debugger&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，terser还提供众多可以配置的构建选项，参看 <a href="https://terser.org/">https://terser.org/</a></p>
<h3 id="模块分割（模块联邦）"><a href="#模块分割（模块联邦）" class="headerlink" title="模块分割（模块联邦）"></a>模块分割（模块联邦）</h3><p>在不使用 CDN 情况下，我们依然需要将第三方包进行build，想想一下，如果你的入口js引入了vue，pinia，router这些，那么你在build之后会发现这些三方库全部被整合到了一个js文件中，导致体积过大，那么此时应该用到的就是模块分割</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和前面一样，该配置属于rollup底层配置，需要写在rollupOptions对象中</span></span><br><span class="line"><span class="comment">// 示例就是将项目中的包，按照功能拆分出独立的模块，或者将一系列相关的功能包，合并到一个模块组合</span></span><br><span class="line"><span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">  <span class="attr">manualChunks</span>: &#123;</span><br><span class="line">    <span class="attr">axios</span>: [<span class="string">&#x27;axios&#x27;</span>],</span><br><span class="line">    <span class="attr">jQuery</span>: [<span class="string">&#x27;jquery&#x27;</span>],</span><br><span class="line">    <span class="comment">// vue + pinia + router属于vue生态链，所以单独合成一个模块</span></span><br><span class="line">    <span class="attr">vue</span>: [<span class="string">&#x27;vue&#x27;</span>, <span class="string">&#x27;pinia&#x27;</span>, <span class="string">&#x27;vue-router&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h3><p>和 webpack 一样，vite 也可以通过配置环境变量来区分逻辑走向，例如 dev 环境用的 api 地址是 <code>http://test.api.com</code>,<br>而生产环境用的是 <code>http://prod.api.com</code>, 那么在使用这个变量就需要做区分，而与 webpack 不同的是，vite 并没有采用 <code>process.env.NODE_ENV</code>，而是使用 esModule 中的 <code>import.meta</code>来识别，具体如下</p>
<p>首先在根目录下创建 <code>.env</code> 文件, 添加环境变量，注意以 <code>VITE_</code>开头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VITE_name = jacky</span><br></pre></td></tr></table></figure>

<p>然后在任意 <code>.js</code> 文件中尝试打印 <code>import.meta.env</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">BASE_URL<span class="punctuation">:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">DEV<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">MODE<span class="punctuation">:</span> <span class="string">&quot;development&quot;</span></span><br><span class="line">PROD<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">SSR<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">VITE_name<span class="punctuation">:</span> <span class="string">&quot;jacky&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以发现配置在 env 文件中的变量已经生效，需要注意一下几点</p>
<ol>
<li>mode 可自由设置</li>
<li>环境变量前缀可自由设置</li>
<li>vite 通过mode，来寻找对应env文件</li>
</ol>
<p>例如，如果 package.json 中 script 命令行中的设置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">dev<span class="punctuation">:</span> vite --mode dev</span><br></pre></td></tr></table></figure>

<p>那么在运行中，vite会尝试寻找根目录下的 <code>.env.dev</code> 文件，后缀就是 –mode 后要跟的内容，如果是<code>.env.prod</code>文件，则需要把 –mode 设置为 prod。</p>
<p>如果需要自定义环境变量前缀，需要在 <code>vite.config.js</code> 中设置 <code>envPrefix</code>: <code>your_custom_profixer</code>，然后在 env 文件中就以此为变量前缀</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="attr">envPrefix</span>: <span class="string">&#x27;jc&#x27;</span>, <span class="comment">//环境变量以jc开头</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>env文件中设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jc_name = 100</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vite</tag>
      </tags>
  </entry>
</search>
